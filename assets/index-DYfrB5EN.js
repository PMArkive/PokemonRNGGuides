async function M(o,y,{concurrency:s=Number.POSITIVE_INFINITY,stopOnError:l=!0,signal:t}={}){return new Promise((E,N)=>{if(o[Symbol.iterator]===void 0&&o[Symbol.asyncIterator]===void 0)throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof o})`);if(typeof y!="function")throw new TypeError("Mapper function is required");if(!(Number.isSafeInteger(s)&&s>=1||s===Number.POSITIVE_INFINITY))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${s}\` (${typeof s})`);const c=[],p=[],d=new Map;let w=!1,a=!1,b=!1,u=0,m=0;const T=o[Symbol.iterator]===void 0?o[Symbol.asyncIterator]():o[Symbol.iterator](),x=()=>{i(t.reason)},h=()=>{t==null||t.removeEventListener("abort",x)},S=e=>{E(e),h()},i=e=>{w=!0,a=!0,N(e),h()};t&&(t.aborted&&i(t.reason),t.addEventListener("abort",x,{once:!0}));const I=async()=>{if(a)return;const e=await T.next(),f=m;if(m++,e.done){if(b=!0,u===0&&!a){if(!l&&p.length>0){i(new AggregateError(p));return}if(a=!0,d.size===0){S(c);return}const r=[];for(const[n,k]of c.entries())d.get(n)!==v&&r.push(k);S(r)}return}u++,(async()=>{try{const r=await e.value;if(a)return;const n=await y(r,f);n===v&&d.set(f,n),c[f]=n,u--,await I()}catch(r){if(l)i(r);else{p.push(r),u--;try{await I()}catch(n){i(n)}}}})()};(async()=>{for(let e=0;e<s;e++){try{await I()}catch(f){i(f);break}if(b||w)break}})()})}const v=Symbol("skip");export{M as p};
